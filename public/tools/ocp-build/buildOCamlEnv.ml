(******************************************************************************)
(*                                                                            *)
(*                          TypeRex OCaml Tools                               *)
(*                                                                            *)
(*                               OCamlPro                                     *)
(*                                                                            *)
(*    Copyright 2011-2012 OCamlPro                                            *)
(*    All rights reserved.  See accompanying files for the terms under        *)
(*    which this file is distributed. In doubt, contact us at                 *)
(*    contact@ocamlpro.com (http://www.ocamlpro.com/)                         *)
(*                                                                            *)
(******************************************************************************)

open BuildObjectInspector

type library = {
  mutable lib_name : string;
  mutable lib_provide : string option;
  lib_dirname : string;

  mutable lib_asm_exists : bool;
  mutable lib_asm_mods : (string * Digest.t) list;
  mutable lib_asm_deps : (string * Digest.t) list;

  mutable lib_byte_exists : bool;
  mutable lib_byte_deps : (string * Digest.t) list;
  mutable lib_byte_mods : (string * Digest.t) list;
}

let dirs = ref []


let null_digest = (String.make 16 '\000' : Digest.t)

let filenames = Hashtbl.create 113
let asm_mods = Hashtbl.create 113
let libnames = ref StringMap.empty

let add_asm_mod modname digest lib =
  try
    let libs = Hashtbl.find asm_mods (modname, digest) in
    match !libs with
      lib1 :: _ when lib1 == lib -> ()
    | _ -> libs := lib :: !libs
  with Not_found ->
    Hashtbl.add asm_mods (modname, digest) (ref [lib])

let add_asm_library lib filename =
  match BuildObjectInspector.load_object_file filename with
  | CMXA desc ->
    lib.lib_asm_exists <- true;
    let cmx_deps = Hashtbl.create 113 in
    let add_cmx_dep key =
      if not (Hashtbl.mem cmx_deps key) then begin
        Hashtbl.add cmx_deps key ();
        lib.lib_asm_deps <- key :: lib.lib_asm_deps
      end
    in

    (* declare modules *)
    List.iter (fun (cmx, digest) ->
      lib.lib_asm_mods <- (cmx.ui_name, digest) :: lib.lib_asm_mods;
      add_asm_mod cmx.ui_name digest lib;
      add_asm_mod cmx.ui_name null_digest lib;
    ) desc.cmxa_units;

    (* find external dependencies *)
    List.iter (fun (cmx, digest) ->
      List.iter add_cmx_dep cmx.ui_imports_cmx;
    ) desc.cmxa_units
  | _ -> assert false

let add_byte_library lib filename =
  match BuildObjectInspector.load_object_file filename with
  | CMA desc ->
    lib.lib_byte_exists <- true;
  | _ -> assert false

let add_new_library filename =
  let lib_name = Filename.basename filename in
  let lib_dirname = Filename.dirname filename in

  let lib = {
    lib_name = lib_name;
    lib_dirname = lib_dirname;
    lib_provide = None;

    lib_asm_exists = false;
    lib_asm_mods = [];
    lib_asm_deps = [];

    lib_byte_exists = false;
    lib_byte_mods = [];
    lib_byte_deps = [];
  } in

  Hashtbl.add filenames filename lib;

  begin try
          let libs = StringMap.find lib_name !libnames in
          libs := lib :: !libs
    with Not_found ->
      libnames := StringMap.add lib_name (ref [lib])  !libnames
  end;

  let asm_filename = filename ^ ".cmxa" in
  if Sys.file_exists asm_filename then
    add_asm_library lib asm_filename;

  let byte_filename = filename ^ ".cma" in
  if Sys.file_exists byte_filename then
    add_byte_library lib byte_filename;

  ()


let add_library filename =
  if not (Hashtbl.mem filenames filename) then
    add_new_library filename


let add_bytecode_library filename =
  Printf.printf "add_bytecode_library %s\n%!" filename;
  add_library (Filename.chop_suffix filename ".cma")

let add_native_library filename =
  Printf.printf "add_native_library %s\n%!" filename;
  add_library (Filename.chop_suffix filename ".cmxa")


let map =
  let map = ref StringMap.empty in
  map := StringMap.add "cma" add_bytecode_library !map;
  map := StringMap.add "cmxa" add_native_library !map;
  !map

let scan_directory dirname =
  Printf.printf "scan_directory %s\n%!" dirname;
  BuildScanner.scan_directory_for_extensions dirname map

let find_longname lib =
  let rec iter dirname lib_name =
    if List.mem dirname !dirs then lib_name else
      let basenane = Filename.basename dirname in
      if basenane = "" then lib_name else
        let dirname = Filename.dirname dirname in
        iter dirname (Printf.sprintf "%s-%s" basenane lib_name)
  in
  iter lib.lib_dirname lib.lib_name

let generate_ocp filename =
  let oc = open_out filename in
  Printf.fprintf oc "(* generated by ocp-build-infer-env *)\n";
  Printf.fprintf oc "begin\n";
  Printf.fprintf oc "  generated = true\n";

(* Generate uniq names for libraries *)
  StringMap.iter (fun lib_name libs ->
    match !libs with
      [ lib ] -> ()
    | libs ->

      let new_names = ref StringMap.empty in
      List.iter (fun lib ->
        let long_name = find_longname lib in
        try
          let libs = StringMap.find long_name !new_names in
          libs := lib :: !libs
        with Not_found ->
          new_names := StringMap.add long_name (ref [lib]) !new_names
      ) libs;

      let counter = ref 0 in
      let rename_lib lib =
        incr counter;
        lib.lib_provide <- Some lib.lib_name;
        lib.lib_name <- Printf.sprintf "%s%d" lib_name !counter
      in
      StringMap.iter (fun long_name libs ->

        if StringMap.mem long_name !libnames && long_name <> lib_name then
          List.iter rename_lib !libs
        else
          match !libs with
            [ lib ] ->
              if long_name <> lib_name then
                lib.lib_provide <- Some lib_name;
              lib.lib_name <- long_name
          | libs ->
            List.iter rename_lib libs
      ) !new_names

  ) !libnames;

  let declare_library lib =

    Printf.fprintf oc "  begin library %S\n" lib.lib_name;
      begin match lib.lib_provide with
        None -> ()
      | Some lib_name ->
        Printf.fprintf oc "    provide = %S\n" lib_name;
      end;
    Printf.fprintf oc "    dirname = %S\n" lib.lib_dirname;

    if not lib.lib_asm_exists then
      Printf.fprintf oc "    has_asm = false\n"
    else begin
      let requires = ref [] in
      let asm_deps = Hashtbl.create 113 in
      Hashtbl.add asm_deps lib.lib_name lib;

      List.iter (fun (modname, digest) ->
        try
          match ! (Hashtbl.find asm_mods (modname, digest)) with
            [ lib ] ->
              if not (Hashtbl.mem asm_deps lib.lib_name) then begin
                Hashtbl.add asm_deps lib.lib_name lib;
                requires := lib.lib_name :: !requires
              end;
          | _ -> ()
        with Not_found -> ()
      ) lib.lib_asm_deps;

      if !requires <> [] then begin
        Printf.fprintf oc "    requires = [ ";
        List.iter (fun lib_name -> Printf.fprintf oc "%S " lib_name) !requires;
        Printf.fprintf oc "]\n";
      end;

    end;

    if not lib.lib_byte_exists then
      Printf.fprintf oc "    has_byte = false\n";
    Printf.fprintf oc "  end\n";
  in

  StringMap.iter (fun lib_name libs ->
    List.iter declare_library !libs
  ) !libnames;

  Printf.fprintf oc "end\n";
  close_out oc








let filename = ref "installed.ocp"

let arg_list = []
let arg_anon s = dirs := s :: !dirs
let arg_usage = " : generate installed.ocp from installation directories"

let _ =
  Arg.parse arg_list arg_anon arg_usage;

  let dirs = List.rev !dirs in
  List.iter scan_directory dirs;
  generate_ocp !filename

